# Head 레이어 상세 설명

YOLOv5n의 Head는 Feature Pyramid Network (FPN) 구조로, Backbone에서 추출한 특징을 다중 스케일로 결합하여 객체 탐지를 위한 특징맵을 생성합니다.

## 개요

- **레이어 범위**: 10-23
- **입력**: Backbone 출력 `(1, 256, 20, 20)` (Layer 9)
- **출력**: P3, P4, P5 특징맵
  - P3: `(1, 64, 80, 80)` - 작은 객체 탐지
  - P4: `(1, 128, 40, 40)` - 중간 객체 탐지
  - P5: `(1, 256, 20, 20)` - 큰 객체 탐지
- **주요 역할**: 다중 스케일 특징 결합 및 탐지용 특징맵 생성

---

## FPN 구조 개요

Head는 다음과 같은 FPN 구조를 가집니다:

```
Backbone Output (256, 20, 20)
    ↓
P5 경로 시작 (Layer 10)
    ├─→ Upsample → P4 경로 (Layer 11-14)
    │       ├─→ Upsample → P3 경로 (Layer 15-17)
    │       │       └─→ P3 출력 (64, 80, 80)
    │       └─→ Downsample → P4 경로 (Layer 18-20)
    │               └─→ P4 출력 (128, 40, 40)
    └─→ Downsample → P5 경로 (Layer 21-23)
            └─→ P5 출력 (256, 20, 20)
```

---

## P5 경로 시작 (Layer 10)

### Layer 10: Conv (Head 시작)
- **구조**: `Conv(256→128, 1×1) + BN + SiLU`
- **입력**: `(1, 256, 20, 20)` (Layer 9 출력)
- **출력**: `(1, 128, 20, 20)`
- **역할**: 
  - 채널 수를 256에서 128로 감소 (경량화)
  - **P5 경로의 시작점**
  - **Layer 22에서 재사용** (Concat)

---

## P4 경로 (Layer 11-20)

### Layer 11: Upsample
- **구조**: `Upsample(×2)` (Nearest Neighbor)
- **입력**: `(1, 128, 20, 20)`
- **출력**: `(1, 128, 40, 40)`
- **역할**: 
  - 해상도를 2배로 증가
  - P4 경로로 전달하기 위한 준비

### Layer 12: Concat
- **구조**: `Concat([Layer 11, Layer 6])`
- **입력**: 
  - Layer 11: `(1, 128, 40, 40)` (업샘플링된 특징)
  - Layer 6: `(1, 128, 40, 40)` (Backbone에서 저장된 특징)
- **출력**: `(1, 256, 40, 40)`
- **역할**: 
  - 다운샘플링된 특징과 업샘플링된 특징을 결합
  - 다중 스케일 특징 통합
  - 저수준 특징(위치 정보)과 고수준 특징(의미 정보) 결합

### Layer 13: C3 Block
- **구조**: `C3(256→128, n=1, shortcut=False)`
- **입력**: `(1, 256, 40, 40)`
- **출력**: `(1, 128, 40, 40)`
- **역할**: 
  - 결합된 특징을 정제
  - 채널 수를 128로 감소
  - **Layer 19에서 재사용** (Concat)
- **shortcut=False**: Residual connection 없음 (FPN에서는 일반적)

### Layer 14: Conv
- **구조**: `Conv(128→64, 1×1) + BN + SiLU`
- **입력**: `(1, 128, 40, 40)`
- **출력**: `(1, 64, 40, 40)`
- **역할**: 
  - 채널 수를 64로 감소
  - **P4 경로의 중간 특징**
  - **Layer 19에서 재사용** (Concat)

---

## P3 경로 (Layer 15-17)

### Layer 15: Upsample
- **구조**: `Upsample(×2)` (Nearest Neighbor)
- **입력**: `(1, 64, 40, 40)`
- **출력**: `(1, 64, 80, 80)`
- **역할**: 
  - 해상도를 2배로 증가
  - P3 경로로 전달하기 위한 준비

### Layer 16: Concat
- **구조**: `Concat([Layer 15, Layer 4])`
- **입력**: 
  - Layer 15: `(1, 64, 80, 80)` (업샘플링된 특징)
  - Layer 4: `(1, 64, 80, 80)` (Backbone에서 저장된 특징)
- **출력**: `(1, 128, 80, 80)`
- **역할**: 
  - 다운샘플링된 특징과 업샘플링된 특징을 결합
  - P3 경로의 특징 통합
  - 가장 높은 해상도의 특징맵 생성

### Layer 17: C3 Block → SAVE (P3)
- **구조**: `C3(128→64, n=1, shortcut=False)`
- **입력**: `(1, 128, 80, 80)`
- **출력**: `(1, 64, 80, 80)` → **SAVE[17] (P3)**
- **역할**: 
  - P3 특징맵 생성 완료
  - 작은 객체 탐지용 (stride=8)
  - **Detect head로 전달**
- **특징**:
  - 가장 높은 해상도 (80×80)
  - 작은 객체 탐지에 효과적

---

## P4 경로 완성 (Layer 18-20)

### Layer 18: Conv (Downsample)
- **구조**: `Conv(64→64, 3×3, s=2) + BN + SiLU`
- **입력**: `(1, 64, 80, 80)` (P3 출력)
- **출력**: `(1, 64, 40, 40)`
- **역할**: 
  - 다운샘플링하여 P4 경로로 전달
  - 해상도를 절반으로 감소
  - P3에서 추출한 특징을 P4에 전달

### Layer 19: Concat
- **구조**: `Concat([Layer 18, Layer 14])`
- **입력**: 
  - Layer 18: `(1, 64, 40, 40)` (P3에서 다운샘플링된 특징)
  - Layer 14: `(1, 64, 40, 40)` (P4 중간 특징)
- **출력**: `(1, 128, 40, 40)`
- **역할**: 
  - P3에서 다운샘플링된 특징과 P4 중간 특징 결합
  - P4 경로의 특징 통합
  - Top-down과 Bottom-up 경로 결합

### Layer 20: C3 Block → SAVE (P4)
- **구조**: `C3(128→128, n=1, shortcut=False)`
- **입력**: `(1, 128, 40, 40)`
- **출력**: `(1, 128, 40, 40)` → **SAVE[20] (P4)`
- **역할**: 
  - P4 특징맵 생성 완료
  - 중간 크기 객체 탐지용 (stride=16)
  - **Detect head로 전달**
- **특징**:
  - 중간 해상도 (40×40)
  - 중간 크기 객체 탐지에 효과적

---

## P5 경로 완성 (Layer 21-23)

### Layer 21: Conv (Downsample)
- **구조**: `Conv(128→128, 3×3, s=2) + BN + SiLU`
- **입력**: `(1, 128, 40, 40)` (P4 출력)
- **출력**: `(1, 128, 20, 20)`
- **역할**: 
  - 다운샘플링하여 P5 경로로 전달
  - 해상도를 절반으로 감소
  - P4에서 추출한 특징을 P5에 전달

### Layer 22: Concat
- **구조**: `Concat([Layer 21, Layer 10])`
- **입력**: 
  - Layer 21: `(1, 128, 20, 20)` (P4에서 다운샘플링된 특징)
  - Layer 10: `(1, 128, 20, 20)` (P5 시작 특징)
- **출력**: `(1, 256, 20, 20)`
- **역할**: 
  - P4에서 다운샘플링된 특징과 P5 시작 특징 결합
  - P5 경로의 특징 통합
  - 최종 특징맵 생성

### Layer 23: C3 Block → SAVE (P5)
- **구조**: `C3(256→256, n=1, shortcut=False)`
- **입력**: `(1, 256, 20, 20)`
- **출력**: `(1, 256, 20, 20)` → **SAVE[23] (P5)`
- **역할**: 
  - P5 특징맵 생성 완료
  - 큰 객체 탐지용 (stride=32)
  - **Detect head로 전달**
- **특징**:
  - 가장 낮은 해상도 (20×20)
  - 큰 객체 탐지에 효과적
  - 가장 많은 채널 수 (256)

---

## FPN 데이터 흐름

### Top-Down 경로 (업샘플링)
```
Layer 9 (256, 20, 20)
    ↓ Layer 10: Conv 256→128
(128, 20, 20)
    ↓ Layer 11: Upsample ×2
(128, 40, 40)
    ↓ Layer 12: Concat with Layer 6
(256, 40, 40)
    ↓ Layer 13: C3 256→128
(128, 40, 40)
    ↓ Layer 14: Conv 128→64
(64, 40, 40)
    ↓ Layer 15: Upsample ×2
(64, 80, 80)
    ↓ Layer 16: Concat with Layer 4
(128, 80, 80)
    ↓ Layer 17: C3 128→64
P3: (64, 80, 80) ✓
```

### Bottom-Up 경로 (다운샘플링)
```
P3 (64, 80, 80)
    ↓ Layer 18: Conv s=2
(64, 40, 40)
    ↓ Layer 19: Concat with Layer 14
(128, 40, 40)
    ↓ Layer 20: C3 128→128
P4: (128, 40, 40) ✓

P4 (128, 40, 40)
    ↓ Layer 21: Conv s=2
(128, 20, 20)
    ↓ Layer 22: Concat with Layer 10
(256, 20, 20)
    ↓ Layer 23: C3 256→256
P5: (256, 20, 20) ✓
```

---

## 특징맵 재사용

다음 레이어들의 출력이 여러 곳에서 재사용됩니다:

- **Layer 10**: Layer 22 (Concat)에서 재사용
- **Layer 14**: Layer 19 (Concat)에서 재사용
- **Layer 13**: Layer 19 (Concat)에서 재사용 (주석에는 없지만 실제로는 사용될 수 있음)

---

## 출력 특징맵 요약

| 특징맵 | Layer | Shape | Channels | Stride | 용도 |
|--------|-------|-------|----------|--------|------|
| P3 | 17 | (80, 80) | 64 | 8 | 작은 객체 탐지 |
| P4 | 20 | (40, 40) | 128 | 16 | 중간 객체 탐지 |
| P5 | 23 | (20, 20) | 256 | 32 | 큰 객체 탐지 |

---

## 관련 문서

- `docs/LAYER_ARCHITECTURE.md`: 전체 레이어 아키텍처
- `docs/BACKBONE_LAYERS.md`: Backbone 레이어 상세 설명
- `docs/DETECT_HEAD.md`: Detect head 상세 설명
- `src/blocks/c3.c`: C3 블록 구현
- `src/ops/upsample.c`: Upsample 구현
- `src/ops/concat.c`: Concat 구현
